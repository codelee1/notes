##算法八大思想

数据结构和算法一直都是程序员的基本内功，数据结构即是计算机存储、组织数据的方式，其实可以和算法搭配起来，
数据结构就是算法实现的容器载体，通过一系列特殊结构的数据集合，能将算法更为高效而可靠的执行起来。

算法是指解题方案准确而完整的描述，算法有千千万万，重要的是领悟其核心思想，而业界公认的常用算法思想有8种，
分别是枚举、递推、递归、分治、动态规划、贪心、回溯和模拟。


###一、枚举

枚举即穷举，穷尽列举。枚举思想是将问题的「可能解」依次列举出来，然后一一代入问题检验，从而从一系列的「可能解」中获得
能够解决问题的精确解。

枚举思想简单，但是有一些考虑点需要注意，如解决问题的一些「可能解/候选解」的筛选条件、「可能解」之间的相互影响、
穷尽「可能解」的代价、以及穷举方式等等。很多时候实际上可以不必追求高大上的复杂算法，反而大道至简，在「可能解」规模
合理的情况下，采用枚举法就能很好的规避算法复杂性带来的冗余和其他问题，同时或许能在一定程度下对空间进行缩减。

枚举的流程为：通过事先确定好的「可能解」，然后逐一进行验证，根据验证结果对「可能解」进行分析和论证。这是一种很明显的
结果导向型思想，简单粗暴的试图从最终结果反向分析「可能解」的可行性。但是在实际中，能够直接通过枚举法来进行求解的
问题少之又少。同时，如果可能接到筛选条件不清晰，从而导致「可能解」的数量和范围都无法进行判断时，枚举就失去了意义。

然而当「可能解」的规模较小，且依次验证的过程容易实施时，枚举思想不失为一个方便快捷的方式。在具体的使用时，尽量
针对应用场景对「可能解」的验证上进行优化。一个优化方向是将问题进行简化，尽可能对需要处理的问题进行模型结构上的精简。
具体可以提现在问题中变量的数目，减少变量的数据，从而根本上降低「可能解」的组合。另一个则是对「可能解」的范围和条件
进行严格的判断，尽可能的剔除掉大部分无效的「可能解」。

小结：大部分枚举不可用的场景都是由于「可能解」的数量过多，无法在有限的空间或有限的时间内完成所有可能性的验证。
不过枚举思想是最接近人的思维方式，在更多情况下是用来帮助我们「理解问题」，而不是「解决问题」。

案例：百钱买百鸡。公鸡一个五块钱，母鸡一个三块钱，小鸡三个一块钱，现在要用一百块钱买一百只鸡，问公鸡、母鸡、小鸡各多少只？
````
代码
````

###二、递推

递推思想与人脑遇到与解决未知问题思想类似，人脑遇到未知问题时，一般都会从已经积累的知识出发，试图从已知推算未知，从而解决问题。
而递推核心思想也是从已知条件出发，逐步推算出问题的解。但是计算机在进行推理的时候，大多是重复性推理，比如今天是1号，
明天则是2号，而不是太阳从东边升起，然后推出西边落下（这里涉及的问题维度有星体、方向、动作）这些较多维度的问题的推理，

递推的过程是每一次推导的结果，可以作为下一次推导的开始或者参与下一次开始，这与迭代、递归的思想有点类似，但是递推
的范围更广一些。

案例：兔子问题。 定一对大兔子每月能生一对小兔子，且每对新生的小兔子经过一个月可以长成一对大兔子,具备繁殖能力，
如果不发生死亡，且每次均生下一雌一雄，问一年后共有多少对兔子？

````
代码
````

###三、递归

递推的兄弟思想就是递归了，在递推中，是逐次对问题进行推导直至得到最终接，而在递归中，则是逐次回归迭代，直至跳出回归。

递归思想其实是将问题转换成规模更小的同类子问题，先解决子问题，再通过相同的求解过程逐步解决更高层次的问题，最终获得最终解。
所以相较于递推而已，递归的范畴更小，要求子问题和父问题的结构相同，但递推从概念上则没有这种约束。

递归的实现就是在函数或者在子过程的内部，直接或间接的调用自己的算法。所以在实现的过程中，最重要的就是确定递归的终止条件，
也就是跳出递归的条件判断，否则程序会在自我调用的无线循环中，最终导致内存溢出而崩溃。

案例：汉诺塔问题。

````
代码
````


###四、分治

分治，分而治之。分治核心思想就两步，一是分，二是治。不过这引申出了一系列问题，即怎么分、怎么治、治后如何等。

分治算法可以看成是一种向下管理的思想，从最高级层层划分，将子任务划分给不同的子模块，进而可以将大问题进行拆分，
对系统的问题粒度进行细化，寻求最底层的最基本的接。在实际应用中，分治算法主要分为两个维度的处理，一是自顶向下，
将主要问题逐层分解子问题；二是自底向上，将子问题逐层递增融入到主问题的求解中。

那怎么分？遵循计算机最擅长的重复运算，划分出来的子问题需要需要相互独立并且与原问题结构特征相同，这样能够保证解决
子问题后，主问题也能顺势解决。

那怎么治？这就涉及到最基本子问题的求解，我们约定最小子问题是能够轻易得到解决的，这样的子问题划分才有意义，所以在
治的环节就是需要对最基本子问题的简易求解。

治后如何？子问题的求解就是为了主问题而服务的。当最基本子问题得到解后，需要层层向上递增，逐步获得更高层次的解，直至
得到原问题的最终接。

流程为：从上而下，再从下而上。先分解，后求解，在合并。

案例：归并排序。

````
代码
````


###五、动态规划

讲分治的时候，最重要的一点是分解出的子问题是相互独立且结构特征相同的，但这一点并不是所有问题都能满足，许多问题的划分
的子问题问问都是相互重叠和相互影响的，那么就很难用分治思想进行有效而干净的子问题划分。
这时候，就需要动态规划了。动态规划同样需要将问题划分成多个子问题，但是子问题之间问问不是相互独立的。当前子问题的解
可以看成是目前多个阶段问题的完整总结。因此这就需要在子问题求解的过程中进行多阶段的决策，同时当前阶段之前的决策都能
都能构成一种最优子结构。这就是所谓的最优化原理

最优化原理，一个最优策略具有这样的性质，不论过去的状态和决策如何，对前面所形成的状态而言，余下的诸决策必须构成最优策略。
同时，这样的最优策略是针对已有作出决策的总结，对后来的决策没有直接影响，只能借用目前最优策略的状态数据。这也被称为无后效性。

动态规划的开始需要将问题按照一定顺序划分为各个阶段，然后确定每个阶段的状态，其中重点是根据决策的方法来确定状态转移方程，
也就是需要根据当前阶段的状态确定下一阶段的状态。在这个过程中，下一状态往往需要参考之前的状态，因此需要在每一次状态
转移的过程中将当前状态变量进行记录，方便之后查找。

动态规划是用来解决多阶段决策的问题，但是实际问题中往往很难有统一的处理方法，必须结合问题的特点来进行算法的设计，这也是
这种算法很难真正掌握的原因。

案例：背包问题。有 n 件物品和容量为 m 的背包，给出物品的重量以及价值。求解让装入背包的物品重量不超过背包容量且价值最大。

````
代码
````


###六、贪心

贪心，即贪图更多，但是这种贪心是目光短浅的，这就导致贪心算法无法从长远出发，只看重眼前的利益。具体来说，在执行过程中，
每一次都只会选择最大的收益，但是总收益并不一定是最大的。这种思路的好处就是选择简单，不需要纠结，不需要考虑未来。但是
局限性也很明显，就是无法保证最后的解释最优解，很容易陷入局部最优解的情况。不过贪心算法每一次做选择的速度很快，同时
判断条件简单，能够比较快速的给出一个差不多的解决方案。

案例：旅行推销员问题。给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。

````
代码
````


###七、回溯

回溯算法也可称作试探性算法，回溯的过程就是在作出下一步选择之前，先对每一种可能进行试探；只要当可能性存在时才会向前迈进。
倘若所有选择都不可能，那么则向后退回到原来的位置，重新选择。

回溯算法很想是一种进行中的枚举算法，在行进过程中对所有可能性进行枚举并判。常用的应用场景就是在树结构、图结构以及
棋盘落子的遍历上。

回溯思想在许多大规模的问题的求解上都能得到有效的运用。回溯能够将复杂的问题进行分步调整，从而在中间过程中对所有可能运用
枚举思想进行遍历。这样往往能够清晰的看到问题解决的的层次，从而可以更好的理解问题的最终解结构。

案例：八皇后问题。在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。

````
代码
````

###八、模拟

许多真实的场景下，由于问题规模太大，变量过多等因素，很难将具体的问题抽象处理，也就无法针对抽象问题的特征来进行算法
的设计。这个时候，模拟思想或许是最佳的解题思路。

模拟的过程就是对真实场景尽可能的模拟，然后通过计算机强大的计算能力对结果进行预测。这相较于上述思想是一种更为宏大的
思想，在实际的模拟过程中，可能系统部件的实现需要上述几个算法思想的参与。

模拟思想说起来是一种很玄幻的思想，没有具体的实现思路，也没有具体的优化策略，只能说具体问题具体分析。
总体的流程是：自定义的，任意的输入，不规则的系统响应，但只是为了一个可靠的理想输出。


###九、总结

算法思想这种东西，实际上是很玄幻的。同一个问题，或许在实现上可以采用不同的思想进行。这八种思想也没有想象中那么高的
独立性，很多思想都是杂糅在一起的，只是角度和侧重点不同。上面的案例也不代表只能用一种思想来解答，只是用来体会一下对应
的算法思想。

作为底层的程序员，最基础的算法思想还是要有的。这种不是具体于某一种算法，而是在更高层次对于系统和需求的理解。
